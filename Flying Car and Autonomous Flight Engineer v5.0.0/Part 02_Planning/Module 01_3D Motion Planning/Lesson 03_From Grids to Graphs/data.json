{
  "data": {
    "lesson": {
      "id": 503791,
      "key": "5a623140-3e28-4ef1-a0f2-104715381c54",
      "title": "From Grids to Graphs",
      "semantic_type": "Lesson",
      "is_public": true,
      "version": "1.0.0",
      "locale": "en-us",
      "summary": "Graphs are really just a way of describing how your search space is connected. Here you'll learn about the tradeoffs between grids and graphs and each can be used in your planning representation.",
      "lesson_type": "Classroom",
      "display_workspace_project_only": null,
      "resources": {
        "files": [
          {
            "name": "Videos Zip File",
            "uri": "https://zips.udacity-data.com/5a623140-3e28-4ef1-a0f2-104715381c54/503791/1538763200950/From+Grids+to+Graphs+Videos.zip"
          },
          {
            "name": "Transcripts Zip File",
            "uri": "https://zips.udacity-data.com/5a623140-3e28-4ef1-a0f2-104715381c54/503791/1538763196963/From+Grids+to+Graphs+Subtitles.zip"
          }
        ],
        "google_plus_link": null,
        "career_resource_center_link": null,
        "coaching_appointments_link": null,
        "office_hours_link": null,
        "aws_provisioning_link": null
      },
      "project": null,
      "lab": null,
      "concepts": [
        {
          "id": 553511,
          "key": "3f497419-4dbd-491f-8010-7aeac4219cd8",
          "title": "Sebastian Introduction",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "3f497419-4dbd-491f-8010-7aeac4219cd8",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 616882,
              "key": "98e789be-9ce3-4699-88e6-622de32791f6",
              "title": "Nd787 C2 L4 00 Sebastian V1",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "MYtJg8fe4U4",
                "china_cdn_id": "MYtJg8fe4U4.mp4"
              }
            }
          ]
        },
        {
          "id": 503792,
          "key": "6c5fed0e-fb71-4957-9965-912e82978f53",
          "title": "Introduction to Graphs",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "6c5fed0e-fb71-4957-9965-912e82978f53",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 551812,
              "key": "b28a2552-1f27-40ff-9f17-d5ba9b86c615",
              "title": "01 Intro To Graphs V3",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "ikh_CDbMwec",
                "china_cdn_id": "ikh_CDbMwec.mp4"
              }
            }
          ]
        },
        {
          "id": 504197,
          "key": "417c5bf3-e35b-49bb-8967-5b923d778813",
          "title": "Waypoint Extraction",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "417c5bf3-e35b-49bb-8967-5b923d778813",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 551814,
              "key": "134b0504-a469-4a28-8821-2c3a8d5668c3",
              "title": "02 Waypoint Extraction V4",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "rI5AJGHStxA",
                "china_cdn_id": "rI5AJGHStxA.mp4"
              }
            }
          ]
        },
        {
          "id": 504198,
          "key": "85f5ff5b-5ab1-4daf-bb43-eb1d55179449",
          "title": "Collinearity",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "85f5ff5b-5ab1-4daf-bb43-eb1d55179449",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 552526,
              "key": "d02ec609-c93e-47ac-a968-bc842e3b3ae5",
              "title": "03 Collinearity V6",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "NsmiEpZKYJU",
                "china_cdn_id": "NsmiEpZKYJU.mp4"
              }
            }
          ]
        },
        {
          "id": 527637,
          "key": "286f789f-bf70-4896-b41c-68907a0c9825",
          "title": "Collinearity Exercise",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "286f789f-bf70-4896-b41c-68907a0c9825",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 552687,
              "key": "cc4a3d0a-e09e-4448-aed2-7378502e195d",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "Collinearity\n===",
              "instructor_notes": ""
            },
            {
              "id": 552689,
              "key": "d102a1e8-45bb-4321-9cd8-276d15a89f86",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2018/February/5a908aab_screen-shot-2018-02-23-at-1.41.46-pm/screen-shot-2018-02-23-at-1.41.46-pm.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/d102a1e8-45bb-4321-9cd8-276d15a89f86",
              "caption": "",
              "alt": "",
              "width": 826,
              "height": 511,
              "instructor_notes": null
            },
            {
              "id": 552693,
              "key": "66cc5e52-9cf5-4614-8ada-e790a26c63c2",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "One way of eliminating unnecessary waypoints in your path is to evaluate whether or not those points are collinear, and remove everything but the endpoints of each collinear series of points.  For three points <span class=\"mathquill\">p_1, p_2</span> and <span class=\"mathquill\">p_3</span> to be collinear, the  [determinant](https://en.wikipedia.org/wiki/Determinant) of the matrix that includes the coordinates of these three points as rows must be equal to zero: \n\n<div class=\"mathquill\">\n\\begin{aligned}\np_1 = (x_1, y_1, z_1) \\\\ \np_2 = (x_2, y_2, z_2) \\\\ \np_3 = (x_3, y_3, z_3) \\\\ \n\\end{aligned}\n</div>\n<div class=\"mathquill\">\n\\begin{aligned}\ndet\n\\Bigg( \n\\begin{bmatrix}\n    x_1  & y_1 & z_1 \\\\\n    x_2 & y_2 & z_2 \\\\\n    x_3 &  y_3 & z_3\n\\end{bmatrix}\n\\Bigg) = 0\n\\end{aligned}\n</div>\n\n",
              "instructor_notes": ""
            },
            {
              "id": 552703,
              "key": "5629e5a1-0f6d-4f14-b027-364b68c7774a",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "For points in three dimensions this is a [necessary but not sufficient condition for collinearity](http://mathworld.wolfram.com/Collinear.html). However, for two dimensional points, evaluating the same determinant with the <span class=\"mathquill\">z</span> coordinate simply set to 1, the determinant being equal to zero indicates that the area of the triangle described by those three points is zero and is a sufficient condition for collinearity: \n\n<div class=\"mathquill\">\n\\begin{aligned}\np_1 = (x_1, y_1, 1) \\\\ \np_2 = (x_2, y_2, 1) \\\\ \np_3 = (x_3, y_3, 1) \\\\ \n\\end{aligned}\n</div>\nAnd the determinant simplifies to :\n<div class=\"mathquill\">\n\\begin{aligned}\nArea = x_1(y_2-y_3) + x_2(y_3-y_1) + x_3(y_1-y_2)\n\n\\end{aligned}\n</div>\n",
              "instructor_notes": ""
            },
            {
              "id": 552698,
              "key": "529161ba-1cd1-45af-8f42-6326d320c20a",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "With Python you can easily evaluate a determinant using `numpy`:\n\n```python\n# Import numpy\nimport numpy as np\n\n# Define some 2D points\np1 = np.array([1, 2])\np2 = np.array([2, 3])\np3 = np.array([3, 4])\n\n# Define a simple function to add a z coordinate of 1\ndef point(p):\n    return np.array([p[0], p[1], 1.])\n\n# Add points as rows in a matrix\nmat = np.vstack((point(p1), point(p2), point(p3)))\n# Compute and print the determinant of the matrix\ndet = np.linalg.det(mat)\nprint(det)\n>>> 0.0\n```",
              "instructor_notes": ""
            },
            {
              "id": 552700,
              "key": "64a23097-3a71-4ff2-81d8-93bedbf1f512",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "So that works, but in the real world your points might not be exactly on a line, but for all intents and purposes you can treat them as collinear.  For example, consider the case where:\n\n```python\n# Define some 2D points\np1 = np.array([1.001, 2.002])\np2 = np.array([1.999, 3.001])\np3 = np.array([2.99, 4.002])\n\n# Add points as rows in a matrix\nmat = np.vstack((point(p1), point(p2), point(p3)))\n# Compute and print the determinant of the matrix\ndet = np.linalg.det(mat)\nprint(det)\n>>> 0.008989\n\n```\nIf these values are in metres, then most likely you can accept these points as collinear for planning a path for your flying car. So a necessary addition if you're using this method is to introduce a threshold, let's call it `epsilon`, which indicates how close to zero the determinant must be in order to consider the points to be collinear. This allows you to impose a criterion for accepting points that are *almost* collinear. So you could add the following to your implementation: \n\n```python\ncollinear = False\nepsilon = 1e-2\n# Compare the absolute value of the determinant with epsilon\nif np.abs(det) < epsilon:\n    collinear = True\n```",
              "instructor_notes": ""
            },
            {
              "id": 552712,
              "key": "3ddd8f16-5623-4644-b9ea-26fe68b87752",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "So that all works just fine, but `np.linalg.det()` uses floating point math, which is necessary if your points are non-integer.  If, however, you're running on a low-power flight computer and working with grid cell locations, which have integer values, you'd rather be using integer arithmetic. ",
              "instructor_notes": ""
            },
            {
              "id": 552714,
              "key": "57de13b5-9ae2-4283-8ee4-fbe7e7948bbd",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "### Collinearity Exercise\n\nIn this exercise, you'll write a function to evaluate the determinant for three points using the `np.linalg.det()` function including a threshold `epsilon` for collinearity.  You'll write another function to compute the determinant in the 2D case using only integer arithmetic and compare with the speed of the 3D implementation. Your takeaways here will be two choices for collinearity testing, one which optimizes for speed, and the other which allows you to set a collinearity threshold for ever-so-slightly wandering lines.\n\nGood luck! And for a peek at our solution scroll to the link at the bottom of the notebook.  ",
              "instructor_notes": ""
            },
            {
              "id": 527638,
              "key": "3308ee00-49c6-4d96-9052-c5bd549828c7",
              "title": null,
              "semantic_type": "WorkspaceAtom",
              "is_public": true,
              "workspace_id": "view9d7db0d8",
              "pool_id": "jupyter",
              "view_id": "9d7db0d8-cdbc-4eea-be87-9c129af69a05",
              "gpu_capable": false,
              "configuration": {
                "id": "reserved",
                "blueprint": {
                  "conf": {
                    "ports": [],
                    "allowSubmit": false,
                    "defaultPath": "/notebooks/Collinearity.ipynb"
                  },
                  "kind": "jupyter"
                },
                "workspaceId": "reserved"
              },
              "starter_files": null
            }
          ]
        },
        {
          "id": 504199,
          "key": "b9a3b6bc-6b35-495e-afb7-f711d9ea1737",
          "title": "Ray Tracing",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "b9a3b6bc-6b35-495e-afb7-f711d9ea1737",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 551818,
              "key": "c6b5abc8-c9b2-4176-b5aa-fe01e58e34a4",
              "title": "04 Ray Tracing V4",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "BiPdcTmi5Yg",
                "china_cdn_id": "BiPdcTmi5Yg.mp4"
              }
            }
          ]
        },
        {
          "id": 504200,
          "key": "13d546b4-4f46-4d24-8297-799fe73fd987",
          "title": "Bresenham",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "13d546b4-4f46-4d24-8297-799fe73fd987",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 551819,
              "key": "b1640ca6-1b64-4627-b523-bfe51c9cb8c9",
              "title": "05 Bresenham V5",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "DhLZnsJxd-E",
                "china_cdn_id": "DhLZnsJxd-E.mp4"
              }
            }
          ]
        },
        {
          "id": 527643,
          "key": "b05f865b-d12a-4e43-ae67-82bcbe04695b",
          "title": "Bresenham Exercise",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "b05f865b-d12a-4e43-ae67-82bcbe04695b",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 552745,
              "key": "076b2705-2ef7-4c14-af88-16659b4dbdce",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "Bresenham's Algorithm\n===",
              "instructor_notes": ""
            },
            {
              "id": 552738,
              "key": "24a62a98-247c-4a0d-ae51-e70da3ac5e8b",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2018/February/5a90a966_screen-shot-2018-02-23-at-3.52.54-pm/screen-shot-2018-02-23-at-3.52.54-pm.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/24a62a98-247c-4a0d-ae51-e70da3ac5e8b",
              "caption": "",
              "alt": "",
              "width": 962,
              "height": 430,
              "instructor_notes": null
            },
            {
              "id": 552744,
              "key": "8d7f7591-7ba1-41db-a182-ddd03aef980e",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "The [Bresenham algorithm](https://www.cs.helsinki.fi/group/goa/mallinnus/lines/bresenh.html) is a way of computing which cells are intersected by a line using only integer arithmetic. \n\nBresenham developed this algorithm to draw lines in a graphics environment. It is simple, fast and can show which pixels need to be illuminated on a screen to plot a particular line. In our case, the screen is our grid map and the pixels are nodes or grid cells. Because we're using this algorithm for collision detection instead of illuminating pixels, we'll implement it in a slightly different way.\n\nYour goal here is to figure out how to get from <span class=\"mathquill\">p_1 = (x_1,\n y_1)</span> to <span class=\"mathquill\">p_2 = (x_2,\n y_2)</span> by starting at <span class=\"mathquill\">p_1</span> and moving 1 unit in the x or y direction until you arrive at <span class=\"mathquill\">p_2</span>. Whether you decide to move vertically or horizontally is determined by your current position with respect to the line connecting <span class=\"mathquill\">p_1</span> and <span class=\"mathquill\">p_2</span>. For example, moving from the point (0, 0) to (7, 5) would look like this:",
              "instructor_notes": ""
            },
            {
              "id": 552826,
              "key": "2ba12d4f-1b3c-4e3c-8d10-32134663acac",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2018/February/5a91f9a7_screen-shot-2018-02-24-at-3.43.29-pm/screen-shot-2018-02-24-at-3.43.29-pm.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/2ba12d4f-1b3c-4e3c-8d10-32134663acac",
              "caption": "Identifying all possible cells in collision with the line",
              "alt": "",
              "width": 575,
              "height": 392,
              "instructor_notes": null
            },
            {
              "id": 552916,
              "key": "c81f5705-cbf1-4cf8-b067-ddb9ce5ace1e",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "The difference between this method and the typical computer graphics implementation is that in computer graphics, it's about drawing lines with pixels rather than collision detection so the cells illuminated end up missing some potential collisions along the way from <span class=\"mathquill\">p_1</span> to <span class=\"mathquill\">p_2</span>.\n\nThere's a [Python package called Bresenham](https://pypi.python.org/pypi/bresenham/0.1) that uses the computer graphics method. We can use this package and run the same process of identifying the cells that lie along a line from (0, 0) to (7, 5) as we did above and you'll see that the result looks a bit different:",
              "instructor_notes": ""
            },
            {
              "id": 552918,
              "key": "7f964770-c54a-479e-91cc-3e36ef693ade",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2018/February/5a9319df_screen-shot-2018-02-25-at-12.17.12-pm/screen-shot-2018-02-25-at-12.17.12-pm.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/7f964770-c54a-479e-91cc-3e36ef693ade",
              "caption": "Computer graphics Bresenham method, where some cells in collision may be missed.",
              "alt": "",
              "width": 577,
              "height": 391,
              "instructor_notes": null
            },
            {
              "id": 552919,
              "key": "0ac579c8-37da-45bf-9621-e57865c3e78c",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "With this second method, there are cells the line crosses that are not identified in the plot and this is because the restriction of only being able to move one step in either x or y is not imposed here. In other words, diagonal motions are allowed in the computer graphics version of this drawing method.  \n\nWhat that means is that if you're using the graphics method, you could potentially miss some cells that are in collision if you're planning a trajectory that flies close to obstacles. This is probably fine if you've padded obstacles with a safety margin in creation of your grid map.\n\n",
              "instructor_notes": ""
            },
            {
              "id": 552825,
              "key": "7b045c31-5746-4876-bd3c-7436337ce17a",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "### Bresenham Exercise\n\nIn this exercise, you'll get a chance to both implement your own version of Bresenham's algorithm as well as play with the Python Bresenham package implementation.  The reason for doing both is that sometimes just using the prebuilt version is fine, but you also need to understand how it can impact your planning solution and how to modify the algorithm to suit your needs if necessary.\n\nTo keep things relatively simple, in the notebook below you'll implement a method for detecting cells that are in collision with a line from points <span class=\"mathquill\">p_1 = (x_1,\n y_1)</span> and <span class=\"mathquill\">p_2 = (x_2, y_2)</span>, where <span class=\"mathquill\">x_1 < x_2</span> and  <span class=\"mathquill\">y_1 < y_2</span>.  Extending this method to work with any <span class=\"mathquill\">p_1</span> and <span class=\"mathquill\">p_2</span> is left as an extra challenge to you! \n\nAfter that you'll have a chance to play around with the package implementation of Bresenham's algorithm. Follow along with the TODOs in the notebook below and if you get stuck, you can check out our solution by scrolling down to the link at the bottom of the notebook.  ",
              "instructor_notes": ""
            },
            {
              "id": 527646,
              "key": "072d0af3-5079-4139-bfe9-0659f69601ce",
              "title": null,
              "semantic_type": "WorkspaceAtom",
              "is_public": true,
              "workspace_id": "view8c17353e",
              "pool_id": "jupyter",
              "view_id": "8c17353e-a7b2-48aa-b372-6d32498bc0c3",
              "gpu_capable": false,
              "configuration": {
                "id": "reserved",
                "blueprint": {
                  "conf": {
                    "ports": [],
                    "allowSubmit": false,
                    "defaultPath": "/notebooks/Bresenham.ipynb"
                  },
                  "kind": "jupyter"
                },
                "workspaceId": "reserved"
              },
              "starter_files": null
            }
          ]
        },
        {
          "id": 527663,
          "key": "b5df5753-2223-49f4-b6a6-e636a317403e",
          "title": "Putting it Together Exercise",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "b5df5753-2223-49f4-b6a6-e636a317403e",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 552748,
              "key": "6a86e638-3af5-4081-9f73-6501906c70f3",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "Putting it all Together\n===",
              "instructor_notes": ""
            },
            {
              "id": 552751,
              "key": "309cd1de-0d98-46f8-a759-858e83db17eb",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2018/February/5a90acf9_screen-shot-2018-02-23-at-4.07.55-pm/screen-shot-2018-02-23-at-4.07.55-pm.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/309cd1de-0d98-46f8-a759-858e83db17eb",
              "caption": "",
              "alt": "",
              "width": 609,
              "height": 524,
              "instructor_notes": null
            },
            {
              "id": 552752,
              "key": "44962a4e-df95-4369-b72a-a65daed8d724",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "### A* in the City\n\nAt this point, you've got the tools to put together a real planning solution! In this exercise, you'll bring them together to find your way through the city. The steps you'll take include:\n\n* Read in your map of the world (`colliders.csv`) and create a grid representation of the environment\n* Define start and goal locations, as well as a heuristic,  and run A* through the grid to find a path of cells.\n* Use collinearity and / or Bresenham to eliminate unnecessary waypoints.\n\nAnd with that you have a planning solution! Follow along with the TODOs in the notebook below and if you get stuck you can always check out our solution by scrolling down to the link at the bottom of the notebook.  \n ",
              "instructor_notes": ""
            },
            {
              "id": 527666,
              "key": "aeeb06f6-7f3c-45b7-942a-5d4861f3cd27",
              "title": null,
              "semantic_type": "WorkspaceAtom",
              "is_public": true,
              "workspace_id": "view6ddbca99",
              "pool_id": "jupyter",
              "view_id": "6ddbca99-3009-4ad6-b3af-147c748a3db1",
              "gpu_capable": false,
              "configuration": {
                "id": "reserved",
                "blueprint": {
                  "conf": {
                    "ports": [],
                    "allowSubmit": false,
                    "defaultPath": "/notebooks/A-Star-City.ipynb"
                  },
                  "kind": "jupyter"
                },
                "workspaceId": "reserved"
              },
              "starter_files": null
            }
          ]
        },
        {
          "id": 504201,
          "key": "dfeadb89-031e-4166-a9bf-ce78415d7cb7",
          "title": "Grids to Graphs",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "dfeadb89-031e-4166-a9bf-ce78415d7cb7",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 551820,
              "key": "20956916-1a40-41f3-9fda-6c167da64c54",
              "title": "06 Grids To Graphs V4",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "DDamvBxXP3I",
                "china_cdn_id": "DDamvBxXP3I.mp4"
              }
            }
          ]
        },
        {
          "id": 504202,
          "key": "44e98a01-fe2c-47ce-aae5-dfa95e080813",
          "title": "Graph Tradeoffs",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "44e98a01-fe2c-47ce-aae5-dfa95e080813",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 551821,
              "key": "a2275446-6586-4272-a1df-33d96d1ec2af",
              "title": "07 Graph Trade Offs V6",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "gQvoAaAYP88",
                "china_cdn_id": "gQvoAaAYP88.mp4"
              }
            }
          ]
        },
        {
          "id": 504203,
          "key": "fb567f43-ffd7-4423-b842-40884c305569",
          "title": "Generating Graphs",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "fb567f43-ffd7-4423-b842-40884c305569",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 551822,
              "key": "08a7291c-5172-4949-b4fd-fe7498954fc7",
              "title": "08 Generating Graphs V4",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "Pj1U6VHs1w4",
                "china_cdn_id": "Pj1U6VHs1w4.mp4"
              }
            }
          ]
        },
        {
          "id": 552947,
          "key": "82275abd-86bc-43c0-a613-06728daffb22",
          "title": "Medial Axis Exercise",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "82275abd-86bc-43c0-a613-06728daffb22",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 552948,
              "key": "ba3c08f3-c55d-4506-8e06-50a9c9956978",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "Medial Axis Skeletonization\n===",
              "instructor_notes": ""
            },
            {
              "id": 552949,
              "key": "5a73f951-8847-4946-8b04-44bbd3349201",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2018/February/5a935e43_screen-shot-2018-02-25-at-5.09.06-pm/screen-shot-2018-02-25-at-5.09.06-pm.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/5a73f951-8847-4946-8b04-44bbd3349201",
              "caption": "",
              "alt": "",
              "width": 971,
              "height": 494,
              "instructor_notes": null
            },
            {
              "id": 552950,
              "key": "79f23569-33fd-4052-af95-7bc7dba35c53",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "The medial axis method is an image processing technique for identifying a \"skeleton\" of a binary image, or in this case, your grid map of obstacles and free space.  In this exercise, you'll be using the [medial_axis()](http://scikit-image.org/docs/0.10.x/auto_examples/plot_medial_transform.html) transform method within the the Scikit-Image library.  \n\nThis method returns the one-pixel-wide skeleton of the image so for instance, when you run it on the grid you've created of the environment from the previous exercises, it looks like this:\n\n```python\nfrom skimage.morphology import medial_axis\nfrom skimage.util import invert\n\n# Assuming you've already created the grid\n# The medial_axis() method requires that we invert the grid image\nskeleton = medial_axis(invert(grid))\nplt.imshow(grid, origin='lower')\nplt.imshow(skeleton, origin='lower', alpha=0.7)\nplt.show()\n```",
              "instructor_notes": ""
            },
            {
              "id": 552951,
              "key": "4d115b68-d5c1-49e7-bb3c-7c226d72ad22",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2018/February/5a936580_screen-shot-2018-02-25-at-5.33.40-pm/screen-shot-2018-02-25-at-5.33.40-pm.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/4d115b68-d5c1-49e7-bb3c-7c226d72ad22",
              "caption": "",
              "alt": "",
              "width": 543,
              "height": 463,
              "instructor_notes": null
            },
            {
              "id": 553254,
              "key": "580da610-f666-4cf9-8cc2-651dac5132f3",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "Now the black pixels represent the medial axis of the free space and now the entire connectivity of your free space is expressed as strings of adjacent pixels laid out along these medial axes between obstacles.  So how can you use this for planning?\n\n### Medial Axis Exercise\n\nIn this exercise, you'll extract a grid map of obstacles and free space as in previous exercises and run the medial axis transform on it to get at the underlying skeleton of the free space.  There are a variety of options for how you could use this output for planning, but the way you'll do it in this exercise is to simply identify the points on the skeleton that are closest to your start and goal locations, then run A* across the skeleton to find a path between these points.  \n\nNext, you can use collinearity or Bresenham (or maybe some other method) to reduce the path you found through the skeleton to a sparse collection of waypoints! If you get stuck you can have a look at our solution by scrolling down to the link at the bottom of the notebook.",
              "instructor_notes": ""
            },
            {
              "id": 553595,
              "key": "2c0e0056-c66f-4cdd-bbb0-8cfd4ebdfdd0",
              "title": null,
              "semantic_type": "WorkspaceAtom",
              "is_public": true,
              "workspace_id": "view6fcb423c",
              "pool_id": "jupyter",
              "view_id": "6fcb423c-fbc8-41ee-a0d5-f05ff7887905",
              "gpu_capable": false,
              "configuration": {
                "id": "reserved",
                "blueprint": {
                  "conf": {
                    "disk": null,
                    "ports": [],
                    "allowSubmit": false,
                    "defaultPath": "/notebooks/Medial-Axis.ipynb"
                  },
                  "kind": "jupyter"
                },
                "workspaceId": "reserved"
              },
              "starter_files": null
            }
          ]
        },
        {
          "id": 552827,
          "key": "0f7d82e6-08ae-4b3f-bcc4-af4295b45acd",
          "title": "Voronoi Graph Exercise",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "0f7d82e6-08ae-4b3f-bcc4-af4295b45acd",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 552828,
              "key": "faed2072-7e64-4a10-94fa-0f969f1ca35d",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "Voronoi Graphs\n===",
              "instructor_notes": ""
            },
            {
              "id": 552829,
              "key": "5c9dd249-6523-4cbe-b7fa-1def3e73bfbb",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2018/February/5a924373_screen-shot-2018-02-24-at-9.01.56-pm/screen-shot-2018-02-24-at-9.01.56-pm.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/5c9dd249-6523-4cbe-b7fa-1def3e73bfbb",
              "caption": "",
              "alt": "",
              "width": 1076,
              "height": 592,
              "instructor_notes": null
            },
            {
              "id": 552830,
              "key": "a4835bb5-5444-4992-a5c1-32d12d3ee7c5",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "Voronoi diagrams can be tricky to construct, but thankfully Python's [SciPy library](https://www.scipy.org/) already has an implementation of the [Voronoi method](https://docs.scipy.org/doc/scipy-0.18.1/reference/generated/scipy.spatial.Voronoi.html) built in! The way this method works is that you need to feed in a set of points that, in our case, represent the obstacles, and create a `Voronoi()` object that contains a graph of the \"ridges\" that define the midline in free space between the obstacles. ",
              "instructor_notes": ""
            },
            {
              "id": 552831,
              "key": "e4cdd165-4b0f-4f65-b26b-4af5a0169d16",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "For example, you can generate some random points and plot up the associated Voronoi graph like this:\n\n```python\n# Import numpy and Voronoi method and plotting routines\nimport numpy as np\nfrom scipy.spatial import Voronoi, voronoi_plot_2d\nimport matplotlib.pyplot as plt\n\n# Generate 50 random points with integer values between 0 and 49\npoints = np.random.randint(50, size=(50, 2))\n# Extract the Voronoi diagram\ngraph = Voronoi(points)\n# Plot it up!\nvoronoi_plot_2d(graph)\nplt.show()\n```\nAnd you get something that looks like this (will look different if you try this at home because values are random):",
              "instructor_notes": ""
            },
            {
              "id": 552832,
              "key": "4d4d5261-5506-48d5-b615-c6649bb6f272",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2018/February/5a924d32_screen-shot-2018-02-24-at-9.43.55-pm/screen-shot-2018-02-24-at-9.43.55-pm.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/4d4d5261-5506-48d5-b615-c6649bb6f272",
              "caption": "",
              "alt": "",
              "width": 812,
              "height": 528,
              "instructor_notes": null
            },
            {
              "id": 552833,
              "key": "69096829-c859-4cb3-8208-29d5c10a6dc3",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "In this image, you can think of the blue points as obstacles (inputs to the Voronoi method), and orange points are the intersections of the Voronoi ridges, or in other words, the nodes in a graph that navigates between the obstacles! \n\nIn the real world, of course, obstacles are not points but they have some size and shape. Still, the Voronoi method can be a useful starting point for generating a planning graph around real world obstacles and that's what we're going to do next!",
              "instructor_notes": ""
            },
            {
              "id": 552943,
              "key": "444dd771-f67e-4a53-aa95-d3a2c0a5247e",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "### Extracting Nodes and Edges\n\nFor the example shown above, the edges in the graph or \"ridges\" as they're often called in the context of Voronoi diagrams, all represent feasible paths to navigate around those point obstacles.  In the upcoming exercise, you'll start by creating a similar graph based on obstacle center points, but then you need to add an additional step to test whether edges in the graph are traversing free or infeasible space. \n\nWithin the `graph` object created in the code snippet above, you've got all the information you need to extract nodes and edges and test for feasibility. The `graph.vertices` attribute contains the x and y positions of each of the vertices (or nodes), and `graph.ridge_vertices` contains the indices that identify each pair of points that define a ridge in the `graph.vertices` list.  I think that will make more sense if I say it in code!\n\n```python\n# Assuming you've created a graph object as shown above\n# You can step through each pair of points that define a ridge like this\nedges = []  # Empty list to contain valid edges\nfor v in graph.ridge_vertices:\n    p1 = graph.vertices[v[0]]\n    p2 = graph.vertices[v[1]]\n\n    # Then you can test each pair p1 and p2 for collision using Bresenham\n    # (need to convert to integer if using prebuilt Python package)\n    # If the edge does not hit an obstacle\n    # add it to the list\n    if not in_collision:\n        edges.append((p1, p2))\n```\n\n",
              "instructor_notes": ""
            },
            {
              "id": 552944,
              "key": "87f3e8b2-6581-44c7-88cb-0450f0aa8fa9",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "Your goal is to plot up all the valid edges and the result should look something like this:",
              "instructor_notes": ""
            },
            {
              "id": 552946,
              "key": "a559b4ab-a201-47ee-a79c-dc38485d8713",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2018/February/5a934733_screen-shot-2018-02-25-at-3.21.36-pm/screen-shot-2018-02-25-at-3.21.36-pm.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/a559b4ab-a201-47ee-a79c-dc38485d8713",
              "caption": "",
              "alt": "",
              "width": 500,
              "height": 421,
              "instructor_notes": null
            },
            {
              "id": 552834,
              "key": "308504a4-248b-4ebb-aae9-f329067d69cd",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "### Voronoi Exercise\nIn the notebook below, you'll read in the map of the world that you've been using in previous exercises and generate a Voronoi graph like the one above for obstacles that are not simple points, but actual 2D polygons in the ground plane.  To accomplish this task, you'll need to fill in the TODOs in the `create_grid_and_edges()` function below.\n\nGood luck! And for a peek at our solution you can scroll down to the link at the bottom of the notebook.",
              "instructor_notes": ""
            },
            {
              "id": 552835,
              "key": "56055069-7615-4e66-87d5-834b6baa999b",
              "title": null,
              "semantic_type": "WorkspaceAtom",
              "is_public": true,
              "workspace_id": "view3ce30264",
              "pool_id": "jupyter",
              "view_id": "3ce30264-6103-4ea2-b9f3-1a9246fe492b",
              "gpu_capable": false,
              "configuration": {
                "id": "reserved",
                "blueprint": {
                  "conf": {
                    "ports": [],
                    "allowSubmit": false,
                    "defaultPath": "/notebooks/Voronoi.ipynb"
                  },
                  "kind": "jupyter"
                },
                "workspaceId": "reserved"
              },
              "starter_files": null
            }
          ]
        },
        {
          "id": 527670,
          "key": "c766ccda-fc5f-4137-8bcf-5cf288318141",
          "title": "Graph Search Exercise",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "c766ccda-fc5f-4137-8bcf-5cf288318141",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 553522,
              "key": "36192d9d-ac4c-4c8d-922a-3629cf5d8f2b",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "Graph Search\n===",
              "instructor_notes": ""
            },
            {
              "id": 553532,
              "key": "e10e68a4-7f4e-45eb-9fcb-6b59dd17d429",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2018/February/5a95caac_screen-shot-2018-02-27-at-1.10.03-pm/screen-shot-2018-02-27-at-1.10.03-pm.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/e10e68a4-7f4e-45eb-9fcb-6b59dd17d429",
              "caption": "",
              "alt": "",
              "width": 666,
              "height": 578,
              "instructor_notes": null
            },
            {
              "id": 553535,
              "key": "0e289c48-be62-4804-b66e-906c92ae099a",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "Alright now things are getting interesting! You've got a couple different methods for building a graph, and you've got some tools you developed previously to search through grids. You may have started to notice that grids and graphs actually have a lot in common, and with the medial axis transform in particular, we're really sort of straddling the divide between grids and graphs.\n\nThe fact is that grids are really just a subset of graphs where all possible actions are of a fixed size and direction. Graphs on the other hand, are more flexible and allow you to define actions over any distance and in any direction. These similarities mean that you can take your grid-based search methods and easily modify them to work on a graph!\n\n",
              "instructor_notes": ""
            },
            {
              "id": 553538,
              "key": "3bb6fe9f-35e7-46ea-94a7-a45b4638b743",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "### Graph-based A\\*\n\nIn the last two exercises you generated graph representations of your search space. The way A* worked for a grid was that in expanding your list of partial plans, you considered the sum of the cost function G and the heuristic H in deciding where to move to next.  \n\nFor graphs-based A\\*, you'll do essentially the same thing. The \"Manhattan distance\" as a heuristic no longer makes sense, but Euclidean distance can still serve as a perfectly valid heuristic estimate.  For the cost function, you can now think of the cost of moving between two nodes as a function of the distance between those nodes in the graph. And with that, you have your graph-based A\\* implementation! ",
              "instructor_notes": ""
            },
            {
              "id": 553547,
              "key": "406b6fbf-3a4a-434e-8f23-eca8ea23b775",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "### NetworkX\n\nIn order to make graph creation and manipulation simple, we're going to leverage a powerful package called [NetworkX](https://networkx.github.io/). With Networkx, it's easy to take the nodes and edges you found using the Voronoi and medial axis methods and arrange them into a single graph object. In this exercise you'll start with the Voronoi method to extract a graph where nodes and edges don't collide with obstacles.  Then you'll use NetworkX to build up a graph object like this:\n\n```\n# Assuming you have already extracted \"edges\"\n# And edges is a list of tuples of the form (p1, p2)\nimport networkx as nx\n\nG = nx.Graph()\nfor e in edges:\n    p1 = e[0]\n    p2 = e[1]\n    dist = LA.norm(np.array(p2) - np.array(p1))\n    G.add_edge(p1, p2, weight=dist)\n\n```",
              "instructor_notes": ""
            },
            {
              "id": 527684,
              "key": "c0758fe1-3182-4dea-a902-82fd54167aea",
              "title": null,
              "semantic_type": "WorkspaceAtom",
              "is_public": true,
              "workspace_id": "viewd3c11bdf",
              "pool_id": "jupyter",
              "view_id": "d3c11bdf-e7d6-4e39-941b-68e2b6b01f63",
              "gpu_capable": false,
              "configuration": {
                "id": "reserved",
                "blueprint": {
                  "conf": {
                    "disk": null,
                    "ports": [],
                    "allowSubmit": false,
                    "defaultPath": "/notebooks/Graph-Search.ipynb"
                  },
                  "kind": "jupyter"
                },
                "workspaceId": "reserved"
              },
              "starter_files": null
            }
          ]
        },
        {
          "id": 528109,
          "key": "5dc6f119-f8e7-41eb-9fcc-86b0683dbc1a",
          "title": "Deadbands",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "5dc6f119-f8e7-41eb-9fcc-86b0683dbc1a",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 551823,
              "key": "03137876-f45d-4cb8-8b0f-aae319435c9a",
              "title": "09 Deadbands V4",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "kswcczWbszA",
                "china_cdn_id": "kswcczWbszA.mp4"
              }
            },
            {
              "id": 559357,
              "key": "694ff35e-650f-4f20-81f2-7d2ea1fb11d3",
              "title": "Deadbands",
              "semantic_type": "RadioQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "694ff35e-650f-4f20-81f2-7d2ea1fb11d3",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "question": {
                "prompt": "Check out the `local_position_callback()` function in the [backyard_flyer.py](https://github.com/udacity/FCND-Backyard-Flyer/blob/solution/backyard_flyer.py) script. What is the deadband radius being used there?",
                "answers": [
                  {
                    "id": "a1520468884675",
                    "text": "0.1 m",
                    "is_correct": false
                  },
                  {
                    "id": "a1520469038789",
                    "text": "1 m",
                    "is_correct": true
                  },
                  {
                    "id": "a1520469040829",
                    "text": "10 m",
                    "is_correct": false
                  }
                ]
              }
            },
            {
              "id": 559378,
              "key": "2b698287-3214-4279-83cb-2d24c7060688",
              "title": "Deadband test",
              "semantic_type": "MatchingQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "2b698287-3214-4279-83cb-2d24c7060688",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "question": {
                "complex_prompt": {
                  "text": "Try resetting the deadband radius in the [backyard_flyer.py](https://github.com/udacity/FCND-Backyard-Flyer/blob/solution/backyard_flyer.py) script to 0.01, 0.1 and 5 and running the script with the simulator. Match each deadband radius with the with the appropriate description of the behaviour of the quad."
                },
                "concepts_label": "Behaviour",
                "answers_label": "Deadband radius",
                "concepts": [
                  {
                    "text": "The quad executes the path quickly but it appears almost circular instead of square",
                    "correct_answer": {
                      "id": "a1520471560967",
                      "text": "5 m"
                    }
                  },
                  {
                    "text": "The quad executes the path more precisely but more slowly than with a 1 m radius.",
                    "correct_answer": {
                      "id": "a1520471785046",
                      "text": "0.1 m"
                    }
                  },
                  {
                    "text": "The quad executes the path precisely, but gets stuck at each waypoint struggling to land within the deadband radius.",
                    "correct_answer": {
                      "id": "a1520480065306",
                      "text": "0.01 m"
                    }
                  }
                ],
                "answers": [
                  {
                    "id": "a1520471560967",
                    "text": "5 m"
                  },
                  {
                    "id": "a1520471785046",
                    "text": "0.1 m"
                  },
                  {
                    "id": "a1520480065306",
                    "text": "0.01 m"
                  }
                ]
              }
            }
          ]
        },
        {
          "id": 504204,
          "key": "64102c5e-089f-4d7d-96a9-54ae9fcc102b",
          "title": "Summary",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "64102c5e-089f-4d7d-96a9-54ae9fcc102b",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 551824,
              "key": "9ac0a8b5-28d5-4ac2-8ed1-64ddb1dee4e9",
              "title": "10 Summary V3",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "RGkoXva9rSc",
                "china_cdn_id": "RGkoXva9rSc.mp4"
              }
            }
          ]
        }
      ]
    }
  },
  "_deprecated": [
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    }
  ]
}