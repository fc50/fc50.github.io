WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:02.835
For a general Bayes filter,

00:00:02.835 --> 00:00:05.370
the measurement update look like this.

00:00:05.370 --> 00:00:07.580
But for calming filters,

00:00:07.580 --> 00:00:10.289
the measurement update looks like this.

00:00:10.289 --> 00:00:14.669
And once again, instead of passing around bel and bel bar,

00:00:14.669 --> 00:00:20.004
we just use the mean and co-variance estimates from the predictions step.

00:00:20.004 --> 00:00:26.189
What happens is, we use this h prime function to get some h of t matrix.

00:00:26.190 --> 00:00:28.560
In the general non-linear case,

00:00:28.559 --> 00:00:32.429
this will require taking the Jacobian of the measurement model.

00:00:32.429 --> 00:00:38.144
But for now this will just wind up being the C matrix from our linear measurement model.

00:00:38.145 --> 00:00:44.730
Then I use this H matrix in the next line to compute what's called the Kalman game.

00:00:44.729 --> 00:00:49.453
The Kalman game is going to be used in the next step to dictate

00:00:49.454 --> 00:00:54.570
how much we should trust our new measurement compared to our previous belief.

00:00:54.570 --> 00:00:57.780
And calculating this Kalman game as a bunch of math,

00:00:57.780 --> 00:00:59.579
but what it does is it takes

00:00:59.579 --> 00:01:03.750
the old co-variance and transforms it using the measurement model,

00:01:03.750 --> 00:01:05.775
and then adds the measurement noise,

00:01:05.775 --> 00:01:09.630
R. Then I transform all of this math which

00:01:09.629 --> 00:01:13.304
took place in the measurement space back into the state space,

00:01:13.305 --> 00:01:15.610
and that gives me this Kalman game.

00:01:15.609 --> 00:01:19.739
All of this math is what you get when you derive

00:01:19.739 --> 00:01:24.534
the Bayes filter update step and you assume that everything is Gaussian.

00:01:24.534 --> 00:01:27.719
It's a long derivation that we won't show here,

00:01:27.719 --> 00:01:29.849
but the thing to take away is that this is

00:01:29.849 --> 00:01:33.434
the mathematically correct way to get this Kalman game.

00:01:33.435 --> 00:01:38.984
Now the next line is where we get our new mean MU or a new status estimate.

00:01:38.984 --> 00:01:41.775
The new mean is just the old mean,

00:01:41.775 --> 00:01:43.350
plus this Kalman game,

00:01:43.349 --> 00:01:46.829
multiplied by the difference between the actual measurement,

00:01:46.829 --> 00:01:50.504
and the measurement I would have expected based on my measurement model.

00:01:50.504 --> 00:01:54.569
So, you can see this moves my estimate in the direction

00:01:54.569 --> 00:01:59.264
of the new measurement by an amount that's dictated by the Kalman game.

00:01:59.265 --> 00:02:01.484
Then finally, I compute

00:02:01.484 --> 00:02:05.810
a new co-variance using some math that takes into account the Kalman game.

00:02:05.810 --> 00:02:09.689
Then I return those update values and

00:02:09.689 --> 00:02:15.034
those are my best possible estimate of the state after making a measurement.

00:02:15.034 --> 00:02:19.079
So, hopefully from those equations and the measurement model,

00:02:19.080 --> 00:02:23.610
you can implement the update stuff for the one D drone we've been discussing.

00:02:23.610 --> 00:02:27.090
Once you've implemented predict and update,

00:02:27.090 --> 00:02:30.090
you've basically implemented a Kalman filter.

00:02:30.090 --> 00:02:34.020
In practice, these predicted update functions might be

00:02:34.020 --> 00:02:38.040
callbacks that get called whenever you set a new control input,

00:02:38.039 --> 00:02:40.799
or receive a new measurement from a sensor.

